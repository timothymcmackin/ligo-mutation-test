#import "./pokeGame.jsligo" "PokeGame"

import Test = Test.Next;
import Tezos = Tezos.Next;

// Default storage
export const initial_storage: PokeGame.storage = {
  pokeTraces: Map.empty,
  feedback: "kiss"
};

export const setUpAccount = ((): address => {
  // Set up test account
  Test.State.reset(2 as nat, list([]) as list<tez>);
  const account1: address = Test.Account.address(0);
  Test.IO.log("Account 1 has balance: " + Test.String.show(Test.Address.get_balance(account1)));
  // Test.IO.log(Test.Address.get_balance(account1));
  return account1;
});

// Deploy contract and return its typed address
const deployInitialContract = ((): typed_address<parameter_of PokeGame.PokeGameContract, PokeGame.storage> => {
  const contract1 = Test.originate(contract_of(PokeGame.PokeGameContract), initial_storage, 0mutez);
  Test.IO.log("Deployed contract 1 to: " + Test.String.show(Test.Typed_address.to_address(contract1.taddr)));
  return contract1.taddr;
});

export const unitTest = (
    account1: address,
    contract1_taddr: typed_address<parameter_of PokeGame.PokeGameContract, PokeGame.storage>
  ): unit => {

  // const contract1Address = Test.Typed_address.to_address(contract1_taddr);

  Test.State.set_source(account1);

  // Deploy another contract
  const contract2Feedback = "Hello!";
  const contract2 = Test.originate(contract_of(PokeGame.PokeGameContract), { ...initial_storage, feedback: contract2Feedback }, 0mutez);
  const contract2Address = Test.Typed_address.to_address(contract2.taddr);
  Test.IO.log("Deployed contract 2 to: " + Test.String.show(contract2Address));


  // Poke with feedback
  const result2 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("pokeAndGetFeedback", contract1_taddr), contract2Address, 0tez);
  match(result2) {
    when(Fail(_err)): failwith("Transaction failed");
    when(Success(_s)): Test.IO.log("Transaction succeeded");
  };

  // Check storage for response
  const storage2: PokeGame.storage = Test.get_storage(contract1_taddr);
  // New trace replaces old because they have the same key
  match(Map.find_opt(account1, storage2.pokeTraces)) {
    when(Some(pokeMessage)):
      do {
        Assert.assert(pokeMessage.feedback == contract2Feedback);
        Assert.assert(pokeMessage.sender == contract2Address);
      };
    when (None()):
      Assert.assert(false)
  };


};

const testContract = ((): unit => unitTest(setUpAccount(), deployInitialContract()))();